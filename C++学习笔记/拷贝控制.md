### 拷贝控制  
当定义一个类时，我们是显示地或隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么,一个类通过定义5种特殊的成员函数来控制这些操作,包括;拷贝构遭函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。　
拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么,拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么,析构函数定义了当此类型对象销毁时做什么，我们称这些操作为拷贝控制操作.  
如果一个类没有定义所有这些拷贝控制成员,编译器会自动为它定义缺失的操作,因此，很多类会忽略这些拷贝控制操作;  
### 拷贝构造函数  
如果一个构造函数的第一个参数是自身类型的引用, 且任何额外参数都有默认值,则此构造函数是拷贝构造函数;拷贝构造函数的第一个参数必须是一个引用类型.  
### 合成拷贝构造函数  
如果我们没有为一个类定义拷贝构造函数,编译器会为我们定义一个,与合成默认构造函数不同,即使我们定义了其他构造函数,编译器也会为我们合成一个拷贝构造函数.   
对于某些类来说,合成拷贝构造函数用来阻止我们拷贝该类型的对象,而一般情况,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中,编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中.  
当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数,当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的还要进行类型转换.  
拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生: 
* 将一个对象作为实参传递给一个非引用类型的形参.  
* 从一个返回类型为非引用类型的函数返回一个对象.  
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员.   
### 　　拷贝赋值运算符　　
与拷贝构造函数一样,如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个; 
在介绍合成赋值运算符之前，我们需要了解一点有关重载运算符的知识。
重载运算符本质上是函数,其名字由operator关键字后接表示要定义的运算符的符号组成,因此,赋值运算符就是一个名为operator=函数，类似于任何其他函数,运算符函数也有一个返回类型和一个参数列表. 
重载运算符的参数表示运算符的运算对象,某些运算符，包括赋值运算符，必须定义为成员函数,如果一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this参数.对于一个二元运算符,例如赋值运算符,其右侧运算对象作为显式参数传递.   
**赋值运算符通常应该返回一个指向其左侧运算对象的引用.**  
合成拷贝赋值运算符用来禁止该类型对象的赋值，如果一个类未定义自己的拷贝赋值运算符,编译器会为它生成一个合成拷贝赋值运算符.  
### 析构函数  
析构函数执行与构造函数相反的操作,构造函数初始化对象的非static数据成员,还可能做一些其他工作,析构函数释放对象使用的资源,并销毁对象的非static数据成员.
析构函数是类的一个成员, 没有返回值,也不接受任何参数,由于析构函数不接受参数,因此它不能被重载,对于一个给定的类, 只会有一个唯一的析构函数.  
在一个构造函数中,成员的初始化是在函数体执行之前完成的,且按照它们在类中出现的顺序进行初始化,在一个析构函数中,首先执行函数体,然后销毁成员,成员的销毁按初始化顺序的逆序销毁.  
隐式销毁一个内置指针类型的成员不会delete它所指向的对象.  
与普通指针不同,智能指针是类类型,所以具有析构函数.因此,与普通指针不同,智能指针成员在析构阶段会被自动销毁.  
### 什么时候会调用析构函数  
无论何时一个对象被销毁,就会调用其析构函数；　　
* 变量在离开其作用域时被销毁.  
* 当一个对象被销毁时,其成员被销毁.  
* 容器(无论是标准库容器还是数组)被销毁时,其元素被销毁.  
* 对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁.  
* 对于临时对象,当创建它的完整表达式结束时被销毁.  
由于析构函数自动运行,我们的程序可以按需分配资源,通常无须担心何时释放这些资源.  
**当指向一个对象的引用或指针离开作用域时，析构函数不会执行.**   
### 合成析构函数   
当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数.类似于拷贝构造函数和拷贝赋值运算符,对于某些类,合成析构函数被用来阻止该类型该类型的对象被销毁,如果不是这种情况, 合成析构函数的函数体基于应该为空.  
### 需要析构函数的类也需要拷贝和赋值操作.
如果一个类需要一个析构函数,我们几乎可以肯定它页需要一个拷贝构造函数和一个拷贝赋值运算符.   
### 需要拷贝操作的类也需要赋值操作,反之亦然.   
无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数.   
### 使用default  
当我们在类内用=default修饰成员的声明时，合成的函数将隐式的声明为内联的(就像任何其他类内声明的成员函数一样),如果我们不希望合成的是成员的内联函数,应该只对成员的类外定义使用=default。
### 阻止拷贝  
##### 定义删除函数  
在新标准下,我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝,删除的函数是这样一种函数,我们虽然声明了它们，但不可以以任何方式使用它们,在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的.   
``` 
struct NoCopy{
NoCopy()=default;    //使用合成的默认构造函数  
NoCopy(const NoCopy &) =delete;    //阻止拷贝 
NoCopy &operator=(const NoCopy&)=delete;   //阻止赋值;
~NoCopy()=default;   //使用合成的析构函数.   
};  
```
* 与=default不同,=delete必须出现在函数第一次声明的时候;  
* 与=default的另外一个不同之处是 ,我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）虽然删除函数的主要用途是禁止拷贝控制成员,但当我们希望引导函数匹配过程中,删除函数也是有用的.   
**析构函数不能是删除的成员**   
对于析构函数已删除的类型,不能定义该类型的变量或释放指向该类型动态分配的指针. 
行为像值的类:  
### 类值拷贝赋值运算符  
赋值运算符通常组合了析构函数和构造函数的操作,类似析构函数,赋值操作会销毁左侧运算对象的资源,类似于拷贝构造函数,赋值操作会从右侧运算对象拷贝数据,但是,非常重要的一点吗与拷贝控制成员不同,swap并不是必要的，但是,对于分配了资源的类,定义swap可能是一种很重要的优化手段.  
使用拷贝和交换的赋值运算符自动就是异常安全的且能正确处理自赋值.    
异常安全的定义就是赋值操作没有完成之前,原来的对象的状态不能改变.
动态内存管理类:   
当我们使用allocator分配内存时，必须记住内存是未构造的.为了使用此原始内存,我们把必须调用construct，在此内存中构造一个对象，传递给construct的第一个参数必须是一个指针，指向调用allocate所分配的未构造的内存空间,剩余参数确定用哪个构造函数。  
alloc_n_copy成员函数  
**alloc_n_copy成员会分配足够的内存来保存给定范围的元素,并将这些元素拷贝到新分配的内存中，此函数返回一个指针pair,两个指针分别指向新空间的开始位置和拷贝的尾后位置**   
```
pair<string *,string*> StrVec::alloc_n_copy(const string *b,const string *e)
{   
    //分配空间保存给定范围的元素  
    auto data=alloc.allocate(e-b);   
    //初始化并返回一个pair，该pair由data和uninitialized_copy的返回值构成  
    return {data.uninitialized_copy(b,e,data)}; 
}
```
### 移动构造函数和std::move 
移动构造函数通常是将资源从给定对象移动，而不是拷贝到正在创建的对象  
move标准库函数，它定义在utility头文件中.   
在类中的free()类成员用for_each()写时用for_each(首迭代器,尾后迭代器,[this](string &p){alloc.destroy(&p);});  
### 右值引用   
所谓的右值引用就是必须绑定到右值的引用,我们通过&&而不是&来获得右值引用.如我们将要看到的，右值引用有一个重要的性质------只能绑定到一个将要销毁的对象，因此，我们可以自由的将一个右值引用的资源“移动到”另一个对象文件中.
我们不能将其绑定到要求转换的表达式、字面值或是返回右值的表达式,右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上,但是不能将一个右值引用直接绑定到一个左值上.   
左值是指表达式结束后依然存在的持久对象.右值是指表达式结束后就不再存在的临时对象,一个区分左值与右值的便捷方法是：看能不能对表达式取地址,如果能,则为左值,否则为右值: 
变量是左值，因此我们不能将一个右值引用绑定到一个左值上，即使这个变量是右值引用类型也不行.  
### 标准库move函数   
虽然不能将一个右值引用直接绑定到一个变量上,但我们可以显式地将一个左值转换为对应的右值引用类型.可以通过调用一个名为move的新标准函数来获得绑定到左值上的右值引用.次函数定义在utility中.  
int &&rr1=32;
int &&rr2=rr1;  //错误,表达式rr1是左值. 
int  &&rr3=std::move(rr1);  
move不提供在using中申明,我们直接调用std::move;  
### 移动构造函数和移动赋值运算符  
类似于拷贝构造函数,移动构造函数的第一个参数是一个右值引用,与拷贝构造函数一样,任何额外的参数都必须有默认实参.  
完成资源移动时，要销毁原对象，并使其指向为空.  
移动操作不应该抛出任何异常.  
与拷贝构造函数不同,移动构造函数不分配任何新内存,它接管给定的内存,在接管内存后，它将给定对象中的指针都置为nullptr;如果我们忘记将其置为空，则销毁移后源对象就会释放掉我们刚刚移动的内存.  
noexcept（它通知标准库我们的构造函数不抛出任何异常）;我们在一个函数的参数列表后指定noexcept,在一个构造函数中,noexcept出现在参数列表和初始化列表开始的冒号之间.  
我们必须在类头文件中的申明和定义中都指定noexcept;  
除非vector知道元素类型的移动构造函数不会抛出异常,否则在重新分配内存的过程中,它就必须使用拷贝构造函数。(移动赋值运算符一样);  
在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设.   
###  合成的移动操作  
如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数 ，编译器不会为它合成移动构造函数和移动赋值运算符  
只有当一个类没有定义任何自己版本的拷贝控制成员 ，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符 
一个类是否定义了自己的移动操作对拷贝操作如何合成有影响，如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的.  
定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作,否则，这些成员默认地被定义为删除的.  
移动构造函数接受StrVec&&，因此只能用于实参是(非static)右值的情形.  
一般来说,一个迭代器的解引用运算符返回一个指向元素的左值,与其它迭代器不同，移动迭代器的解引用运算符生成一个右值引用。  
通过调用标准库的make_move_iterator函数将一个普通的迭代器转换为移动迭代器,此函数接受一个迭代器参数，返回一个移动迭代器.  
我们可以将一对移动迭代器传给算法,特别是,可以将移动迭代器传递给uninitialized_copy; 在新标准中,我们希望强制左侧运算对象(即,this指向的对象)是一个左值.  
我们指出this的左值/右值属性的方式与定义const成员函数相同,即,在参数列表后放置一个引用限定符.  
``` 
class FOO{
public:
    FOO &operator=(const FOO&) &;  //只能向可修改的左值赋值.  
};
FOO &FOO::operator=(const FOO &rhs) &
{
    //执行将rhs赋予本对象所需的工作.
    return *this;
}
```  
引用限定符可以是&或&&，分别指出this可以指向一个左值或右值,类似const限定符,引用限定符只能用于(非static)成员函数.且必须同时出现在函数申明和定义中.  
对于&限定的函数,我们只能将它用于左值;对于&&限定的函数,只能用于右值.  
一个函数可以同时用const和引用限定。在此情况下,引用限定符必须跟随在const限定符之后
### 重载和引用函数  
如果一个成员函数有引用限定符,则有相同参数列表的所有版本必须有引用限定符.  









