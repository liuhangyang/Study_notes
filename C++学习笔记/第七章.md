定义和声明成员函数的方式与普通函数差不多,成员函数的声明必须在类的内部,它的定义则既可以在类的内部，也可以在类的外部;作为接口组成部分的非成员函数,例如add,read和print等,它们的定义和声明都应该在类的外部;
定义在类内部的函数是隐式的inline函数;
成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象,当我们调用一个成员函数时，用请求该函数的对象地址初始化this.编译器负责把total的地址传递给isbn的隐式参数this,可以等价的认为编译器将调用重写成如下的形式.
,任何对类成员的直接访问都被看成this的隐式引用,也就是说,当访问成员变量bookNO时，　它隐式的使用this指向的成员.因为this的目的总是指向这个"对象", 所以this是一个常量指针,我们不允许改变this中保存的地址;
isbn紧随列表之后的const关键字，这里，const关键字的作用是修改隐式this指针的类型;
编译器分两步处理类, 首先编译成员的声明，然后才轮到成员函数体,因此，成员函数体可以随意使用类中的其它成员而无须在意这些成员出现的次序;
如果非成员函数是类接口的组成部分,则这些函数的声明应该与类在同一个头文件中.
IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们，而且，因为读取的内容和写入内容的操作都会改变交流的内容，所以两个函数都是普通引用,而非常量的引用;
默认情况下,拷贝类的对象其实拷贝的是对象的数据成员;
构造函数:
构造函数的任务是初始化类对象的数据成员,无论何时只要类被创建,就会执行构造函数　；
构造函数不能有返回值;
构造函数不能被声明为const的,当我们创建类的一个const对象时，直到构造函数完成初始化过程,对象才能真正取得其“常量”的属性,因此，构造函数在const对象的构造过程中可以向其写值;
1.含有内置类型或复合类型的成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数，否则，用户在创建类的对象就可能得到未定义的值;
2.如果包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造器；
如果类中包含一个其它类的成员的类型，且这个成员的类型没有默认的构造函数，那么编译器将无法初始化该类成员;
如果我们定义了其它的构造函数，那么也必须定义一个默认的构造函数./
在c++11新标准中, 如果我们需要默认的行为,那么我们可以通过在参数列表后面写=default来要求编译器生成构造函数,其中,=default既可以和声明在一起出现在类的内部,也可以作为定义出现在类的外部,和其它函数一样,如果=default在类的内部，则默认构造函数是内联的,如果它在类的外部,则该成员默认情况下不是内联的.
当某个数据成员被构造函数初始化值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化;










