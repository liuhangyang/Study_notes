1一个类可以很多种初始化对象的方式,只不过这些方式之间必须有所区别;或者是初始值的数量不同,或者是初始值的类型不同.
string s1;  //默认初始化为空字符串.除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去;
string s4(10,'c')    //s4的内容是cccccccccc;如果提供一个数字和一个字符,则string对象的内容是给定字符连续重复若干次得到的序列.
初始化string对象的方式
string s1;
string s2(s1) //s2是s1的副本   //直接初始化    s1本来已经存在,所以不需要调用相应的构造函数,而是直接调用复制构造函数;
string s2 = s1; //等价于s2(s1);  //复制初始化     s1本来已经存在,所以不需要调用相应的构造函数,而是直接调用复制构造函数,把s1的值拷贝给s2;
string s3("value"); s3是字面值"value"的副本,除了字面值最后的那个空字符外              直接调用对应的构造函数,不用拷贝构造函数.
string s3="value"  //等价于s3("value");                                      它首先调用构造函数函数创建一个临时变量,然后调用拷贝构造函数,把这个临时对象作为参数,构造对象s3;
string s4(n,'c') //把s4初始化为由连续n个字符组成的串;
如果使用等号(=)初始化一个变量,实际上是执行拷贝初始化,编译器直接把等号右边的初始值拷贝到新创建的对象中去,如果不使用等号,则执行的是直接初始化;
对于用多个值进行初始化的情况,非要用拷贝初始化的方式来处理也不是不可以,不过需要显式的创建一个(临时)对象用于拷贝.
string s8 = string(10,'c');

直接初始化和拷贝初始化的区别:简单的来说,就是定义对象时的写法不同,一个是用括号,一个是用等号,如string s2(s1);如string s2=s1;
但是从本质上来说,它们有本质的不同,直接初始化直接调用与实参匹配的构造函数,拷贝初始化总是调用拷贝构造函数,拷贝初始化首先使用指定构造函数创建一个临时对象,然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象,所以当拷贝构造函数被申明为私有时,所有的拷贝初始化都不能使用.
  
直接初始化不一定要调用拷贝构造函数,而拷贝初始化一定会调用拷贝构造函数.

编译器会帮你做很多你看不到,你不知道的优化,有时,我们看到的结果正是编译器优化过后的运行结果.




string对象上的操作
os << s  将s写到输出流os当中, 返回os;
is >> s  从is中读取字符串赋给s,字符串以空白分隔,返回is;
getline (is,s)  从is 中读一行赋给s,返回is
s.empty()s为空返回true,否则返回false;
s.size()返回s中的字符的个数;
s[n]   返回s中第n个字符的引用,位置n从0记起;
s1+s2 返回s1+s2连接后的结果
s1=s2   用s2的副本代替s1中原来的字符
s1 == s2   如果s1和s2中所含的字符完全一样,则它们相等;string对象的相等性对大小写敏感;

string对象会自动忽略开头的空白(即空格 换行符  制表符),并从第一个真正的字符开始读起,直到遇见下一处空白为止;
getline(is,s)函数从给定的输入流中读取内容,知道遇到换行符为止(注意换行符也被读进来了),然后把读到的数据存到s这个string对象之中;
触发getline函数返回的那个换行符实际上被丢弃掉了, 得到的string对象中并不包含该换行符;

string::size_type类型
size()函数返回的是一个string::size_type类型的值  unsigned int /unsigned long unsigned long long 等;
当把string对象和字符字面值及字符串字面值混在一条语句时,必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string对象;字符串的字面值与string是不同的类型;
cctype头文件中的函数
isalnum(c)  当c是字母或数字时为真
isalpha(c)   当c是字母时为真
iscntrl(c)   当c是控制字符时为真
isdigit(c)    当c是数字时为真
isgraph(c)    当c不是空格但可以打印时为真
islower(c)   当c是小写字母时为真
isprint(c)   当c是可以打印的字符时为真(即c是空格或具有可视形式)
ispunct(c)   当c是标点符号时为真
isspace(c)   当c是空白时为真
isupper(c)   当c是大写字母时为真
tolower(c)   如果c是大写字母,输出小写,否则原样输出
toupper(c)  如果c是小写字母,输出大写,否则原样输出　．
如果想改变string对象中字符的值，必须把循环变量定义成引用类型的，所谓引用只是给定对象的一个别名,因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到每个元素上,;
string对象的下标必须大于等于０而小于s.size();

无论何时，都要检查字符串的下标是否合法;

标准库类型vector：标准库vector表示对象的集合,其中所有对象的类型都相同,集合中每个对象都有一个与之对应的索引，索引用于访问对象.vector是一个类模板;
列表初始化vector对象;
vector<str> arctitle={"a","an","the"};
使用拷贝初始化时(即使用=时),只能提供一个初始值;其二，如果提供一个类内初始化值，则只能使用花括号的形式初始化,第三种特殊的要求是，如果提供的是初始元素值列表，则只能把初始值都放在花括号里进行列表初始化,而不能放在圆括号里.
vector<string> v1{"a","an","the"};  //列表初始化
vector<string> v2("a","an","hi!");  //错误
创建指定数量的元素:
vector<int> ivec(10,-1);   //10个int 类型的元素,每个都被初始化为-1;
vector<string> sevc(10,"hi!")  //10个string类型的元素,每个都被初始化为"hi!";
值初始化:
如果vector对象的元素是内置类型,比如int，则元素初始值自动设为0,如果元素是某种类型,比如string，则元素由类默认初始化.
vector<int> ivec(10);    //10个元素,每个都初始化为0
vector<string> svec(10),;  //10个元素,每个都是空string对象.
这种初始化的两个限制:其一，有些类要求必须明确地提供初始值,如果vector对象中的元素的类型不支持默认初始化,我们就必须提供初始的元素值.对于这中类型的对象来说,只提供元素的数量而不设定初始值是无法完成初始化工作的.
其二：如果只提供了元素的数量而没有设定初始值,只能使用直接初始化.
初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号:
vector<int> v1(10);   //v1有10个元素，每个的值都是0
vector<int> v2{10};   //v2中有１个元素，该元素的值是10
vector<int> v3(10,1)   //v3有10个元素，每个的值都是1
vector<int> v4{10,1}  //v4有２个元素，值分别是10和1

如果用的是圆括号,可以说提供的值是用来构造vector对象的.v1的初始值说明vector对象的容量.v1的初始值说明了vector对象的容量,v3的两个初始值分别说明了vector对象的容量和元素的初值.
如果初始化使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了
vector<string> v5{"hi"};   //列表初始化,v5有一个元素
vector<string>  v6("hi");  //错误，不能使用字符串字面值构建vector对象
vector<string> v7{10};  //v7有10个默认初始化的元素　　　　　//确认无法执行列表初始化后,编译器尝试用默认值初始化vector对象
vector<string>  v8{10,"hi"};   //v8有10个值为"hi"的元素；

    
向vector对象中添加元素
直接初始化只适合于初始值已知或者数量较少(或初始值相同)；
如果元素较多且不相同时,可以先创建空的vector对象,然后在运行时利用vector的成员函数push_back向其中添加元素. push_pack负责把一个值当成vector对象的尾元素＂压到vector对象的尾端＂;
其他支持vector的操作:
v.empty()　　　//如果v不含有任何元素,返回真，否则返回假;
v.size()　　　　//返回v中元素的个数
v.push_back(t)  //向v的尾端添加一个值为t的元素
v[n]   //返回v中第n个位置的引用
v1=v2    //用v2中的元素拷贝替换v1中的元素
v1={a,b,v....} 用列表中的元素替换v1中的元素
v1==v2　　v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同　
v1 !=v2　＜，＜＝　＞　＞=  //字典顺序　
vector对象 (以及string对象)的下标运算符可用于访问已经存在的元素，而不能用于添加元素;
迭代器:如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等，否则就说这两个迭代器不相等.
标准容器迭代器所指元素的引用
*iter    返回迭代器iter所指元素的引用.
iter->mem    解引用iter并获取该元素的名为mem的成员,等价于(*iter).mem;
++iter       令iter指示容器中的下一个元素   迭代器的递增则是将迭代器"向前移动一个位置"; end返回的迭代器并不实际指示某个元素,所以不能对其进行递增或解引用操作.但是可以进行递减操作.
--iter       令iter指示容器中的上一个元素
iter1 == iter2   iter1 != iter2 判断两个迭代器是否相等(),如果两个迭代器提示的是同一个元素或者它们是同一个容器的尾后迭代器,则相等,反之,不想等
所有标准容器的迭代器都定义了==和!=,但是它们中的大多数都没有定义<运算符;
那些拥有迭代器的标准库使用iterator和const_iterator来表示迭代器的类型;
vector<int>::iterator it   //it能读vector<int>中的元素     //如果用的是const_iterator来表示迭代器的类型,则只能读元素,不能写元素
string::iterator it2               //it2能读写string对象中字符
每个容器类定义了一个名为iterator的类型,该类型支持迭代器概念所规定的一套操作;
如果对象需要读操作而无须写操作的话最好使用常量类型;(const_iterator),c++11中定义了两个函数cbegin和cend函数;无论vextor对象(string对象)本身是否是常量,返回值都是coonst_iterator;
箭头运算符把解引用和成员访问两个操作结合在一起,也就是说it->mem和(*it).mem表达的意思是相同的.


数组:
默认情况下,数组的元素被默认初始化,和内置类型的变量一样,如果在函数内部定义了某种内置类型的数组,那么默认初始化会令数组含有未定义的值.
数组的元素必须是对象,没有引用的数组(即元素类型是数组)
数组允许定义数组的指针即数组的引用;
int *ptrs[10];    //ptrs是含有10个整数指针的数组
int &refs[10];     //错误:不存在引用的数组
int (*Parray)[10]=&arr;  //Parray指向一个含有10个整数的数组
int (&arrRef)[10]=arr;   //arrRef引用一个含有10个整数的数组
int a[]={0,1,2,3,4,5,6,7,8,9};//a是一个含有10个整数的数组
auto p(a);此写法等于auto p(&a[0]); //p是一个整形指针,指向p的第一个元素;

当使用decltype关键字时上述转换不会发生,decltype(a) p; 返回的是由10个整数构成的数组;.  
标准库函数库begin和end函数;C++11新标准中引入的两个名为
begin和end的函数, 这两个函数和容器中的两个 同名成员功能类似, 但是数组不是类,因此这两个函数不是成员函数.
int a[]={1,2,3,4,5,6,7,8,9,10};
int *beg=begin(a);  //指向a首元素的指针
int *last=end(a);   //指向a尾元素的下一个位置的指针   这两个函数都在std中
和迭代器一样,参与运算的两个指针必须指向同一个数组的元素;
比较标准库string对象的时候,用的是普通的关系运算符和相等性运算符;
当使用数组的时候其实真正用的是指向数组首元素的指针;
const char a[]="A string example";
const char b[]="A different string";
a,b只是数组a,b的指针,并不能进行比较;


混用string对象和C风格字符串 
1.允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值.
2.在string对象的加法运算中允许使用空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是);在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象;
不能用string对象直接初始化指向字符的指针,为了完成该功能,string专门提供了一个名为c_str的成员函数.
string a("yang");
const char *str=s.c_str();//正确;
c_str函数的返回值是一个c风格的字符串,也就是说, 函数的返回结果是一个指针,该指针指向一个以空字符结束的字符数组,而这个数组所存的数据恰好与那个string对象一样,结果指针的类型是const char*,从而保证了我们不会改变字符数组的内容 ;
如果执行完c_str()函数后程序想一直使用其返回的数组,最好将该数组重新拷贝一份;

不允许使用一个数组为另一个内置类型的数组赋初值,也不允许使用vector对象初始化数组.
相反的,允许使用数组来初始化vector对象 .要实现这一目标,只需要指明要拷贝区域的首元素地址和尾后地址就可以了;
要使用范围for语句处理多维数组,除了最内层的循环外,其他所有循环的控制变量都应该是引用类型;
using int_array=int[4];
typedef int int_array[4];



























































































    






























