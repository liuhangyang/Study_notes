1,运算对象转换:整数能转换成浮点数,浮点数也能转换成浮点数,但是指针不能转换成浮点数,小整数类型(如bool,char,short等)通常会被提升成较大的我整数类型.主要是int.
重载运算符:我们使用重载运算符时,其包括运算对象的类型和返回值的类型,都是由该运算符定义的,但是运算对象的个数,运算符的优先级和结合律都是无法改变的.
左值和右值2015年11月29日 16时28分57秒 
一个左值表达式的求值结果是一个对象或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象.
总结一下来说:当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的时候,用的是对象的身份(在内存中的位置);
不同的运算符对运算对象的要求各不相同,有的需要左值运算对象,有的需要右值运算对象,返回值页有差异,有的需要左值结果,有的需要右值结果.
1.赋值运算符需要一个(非常量)左值作为其左侧运算对象,得到的结果也仍然是一个左值.
2.取地址符作用于一个左值运算对象,返回一个指向该运算对象的指针.这个指针是一个右值 ;
3.内置解引用运算符,下标运算符,迭代器解引用运算符,string和vector的下标运算符的求值结果都是左值;
假定p的类型是int *,因为解引用运算符生成左值,所以decltype(*p)的结果是int&,另一方面,因为取地址运算符生成右值,所以decltype(&p)的结果是int **；
<<运算符没有明确的规定何时以及如何对运算对象求值,因此下面的输出表达式是未定义的.
boiol值不参与运算;bool值只有0为假,其余的值都为真,负数页为真；
前置版本的递增递减避免了不必要的工作,它把值加1后直接返回了改变了的运算对象,与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费.
条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通长需要在调用它的两端加上括号,
关于符号位如何处理没有明确的规定，所以建议将位运算符用于处理无符号的类型;
左移运算符(<<)，在右侧插入值为0的为0的二进制位,右移运算符(>>)的行为则依赖于左侧运算对象的类型,在左侧插入值为0的二进制位，如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位,
位求反运算符:char类型的运算对象首先提升成int类型,提升时运算对象原来的位保持不变,往高位添加0即可,因此，在本例中,首先将bites提升为int类型; 
在sizeof运算对象中解引用一个无效指针仍然是一种安全的行为,因为指针实际上并没有被真正的使用，sizeof不需要真的解引用指针也能知道它所指对象的类型;
sizeof运算符的结果部分依赖于其作用的类型;
对char或者类型为char的表达式执行sizeof运算,结果得1
对引用类型执行sizeof运算得到被引用对象所占空间的大小.
对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小,指针不需要有效;
对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得的结果求和;注意;sizeof运算不会把数组转换成指针来处理,   
对string对象或vector对象执行sizeof运算只返回该类型的固定部分的大小,不会计算对象中的元素占了多少空间.
何时发生隐式转换:
在大多数表达式中,比int类型的整数值首先会提升为较大的整数类型;
在条件中,非布尔值转换成布尔类型;
初始化过程中,初始值转换成变量的类型，在赋值语句中,右侧运算对象转换成左侧对象的类型；
如果算术运算或关系运算的运算对象有多种类型,需要转换成同一种类型;
在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针.
当数组被用作decltype关键字的参数，或者作为取地址符(&),sizeof及typeid等运算符的运算对象时，上述转换不会发生,同样的,如果用一个引用来初始化数组,上述转换也不会发生.】c++还规定了几种其它的指针的转换方式,包括常量整数值0,或者字面值nullptr能转换成任意指针类型:指向任意非常量的指针也能转换成void *,指向任意队对象的指针能转换成const void*。
存在一种从算术类型或指针类型向布尔类型转换的机制,如果指针或算术类型的值为０，转换的结果是false;否则转换结果是true，
转换成常量:允许将指向非常量类型的指针转换成指向相应的常量类型的指针.对于引用也是这样的,例如:
int i;
const int　&j=i;
const int *p=&i;
命名的强制类型转换,一个命名的强制类型转换具有如下的形式:
cast-name<type>(expression)
type是转换的目标的类型而expression是要转换的值,如果type是引用类型，则结果是左值,case－name是static_cast,dynamic_cast,const_cast和reinterpret_cast中的一种。
static_cast:任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用，此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失,一般来说,如果编译器发现一个较大的算术类型试图赋值给较小的类型时,就会给出警告信息,但是，党当我们执行了显示的转换之后,警告就会被关闭了; 
const_cast该运算符用于除去const属性，即将指向const对象的指针转换指向非const对象的指针,const_cast只可以对指针和引用使用, 如果你要把一个const对象值转换为非const对象值只能用隐式执行或通过使用static_cas 等　例如:const int j=9;int *p=&j;这时，我们不能通过改变*p的值来修改j的值,但是，如果我们如果用int *p=const_cast<int *>(&j),这时，我们就可以通过改变*p的值来改变j的值;
throw表达式:异常检测部分使用throw表达式来表示它遇到了无法处理的问题;
try语句块:异常处理部分使用try语句块处理异常,try语句以关键字try开始,并以一个或多个catch字句结束,try语句块中代码抛出通常会被某个catch语句处理.
定义的异常类也在std空间中.













-                                                                                































                      　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
