## １.构造函数
##### 在类的外部定义构造函数  

```
Sale_data::Sale_data(std::istream &is)
{
    read(is,*this);                              //read函数的作用是从is中读取一条交易信息然后存入this对象;
}  
```
当我们在类的外部定义构造函数时，必须指明该构造函数是哪个类额成员.  
>**在外部定义的构造函数必须在类的内部进行声明**  

##### 拷贝，赋值和析构  

除了定义类的对象如何初始化之外，类还要控制拷贝，赋值和销毁对象时发生的行为;对象在以下几种情况下会被拷贝:  
1.我们初始化变量以及以值的方式传递或返回一个对象等.当我们使用等号赋值等号运算符时,会发生拷贝初始化.
2.当对象不存在时执行销毁的操作,一个局部对象会在创建它的块结束时被销毁,当vector对象(或者数组)销毁时存储在其中的对象也会被销毁.  
如果我们不定义这些操作, 则编译器将替我们合并,编译器生成的版本将对对象的每个成员执行拷贝，赋值，销毁.比如: total = trans;  它的行为和下面代码相同:  
>total.bookNO = trans.bookNO;  
total.units_sold = trans.units_sold;  
>total.revenue = trans.revenue;  

当我们对含有vector成员的对象执行拷贝和赋值操作时，vector类会设法拷贝或者赋值成员中的元素, 当这样的对象被销毁时，将销毁vector对象，也就是会vector对象中的每一个元素.
## 7.2.访问控制与封装  
##### 1.访问控制符　　
- 定义在public说明符之后的成员在整个程序内可以被访问,public成员定义类的接口
- 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问,private说明符部分封装了类的实现细节. 
##### 2.使用class或者struct关键字　　
struct和class唯一的区别点是struct和class的默认访问权限不太一样,struct默认的访问权限是public,class的默认访问权限是private;  
封装性:封装是面向对象的方法的一个重要原则,封装的含义有两个:结合性：即将属性和方法结合，信息隐蔽性，利用接口机制隐藏内部的细节。因此封装的目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性.  
#### 7.21 友元　　
类可以允许其他类或者函数访问它的非共有成员,方法是令其他类或者函数成为它的友元.  
友元声明只能出现在类的内部.  
友元的声明仅仅指定了访问的权限，而非一般意义上的函数声明，如果我们希望类的用户能够调用某个友元函数，因此，我们的头文件应该为这些函数提供独立的声明.  
## 7.3 类的其它特性  
这些特性包括：类的成员，类的成员的类内初始值，可变数据成员，内联成员函数，从成员函数返回*this等;  
#### 7.3.1  类的成员再探  
在类中除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名,由类定义的类型名字和其它成员一样存在访问限制;  
```
    calss Screen {
    public:
        typedef std::string::size_type pos;  //或者用using pos = std::string::size_type;
    private:
        pos cursor=0;
        pos height = 0,width = 0;
        std::string contents;
};
```
 用来定义类型成员必须先定义后使用；类型成员通常出现在类开始的地方;  
##### 可变数据成员
在一个const 成员函数内，通过关键字mutable.  
一个可变的数据成员永远不会是const,即使它是const对象的成员,因此一个const成员函数可以改变一个可变成员的值.  
##### 返回*this的函数
如果返回的类型是引用类型的,则返回的是调用函数本身对象的引用.  
如果返回类型不是引用类型的,则返回的是调用函数本身对象的副本.  
一个const成员函数如果以引用的形式返回*this,那么它的返回类型将是常量引用.  
##### 基于const的重载  
非常量版本的函数对于常量对象是不可用的,所以我们只能在一个常量对象上调用const成员函数.虽然可以在非常量对象上调用常量版本或者非常量版本，但是，非常量版本是一个更好的匹配.  
##### 不完全类  
在声明之后定义之前是一个不完全类,不完全类可以定义指向这种类型的指针或者引用，也可以声明以不完全类型作为参数或者返回类型的函数.  
## 7.3.4  
##### 类之间的友元关系
如果A类需要访问B类的私有成员,则可以在B类中将A类定义为其友元类,例如:  
```
class A{    //A类想访问B类的私有成员
}
class B{
friend class A;
}
```
如果一个类指定了友元类，则友元类的成员函数 可以访问此类包括非公有成员在内的所有成员.   
友元关系不存在传递性.  
##### 另成员函数作为友元  
每个类负责自己的友元类或友云函数.如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每个分别声明.   
##### 友元声明和作用域  
类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明中时，我们隐式的假定该名字在当前作用域是可见的.然而，友元本身不一定真的声明在当前作用域中。  
甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见，换句话说，即使我们仅仅是用声明友元的类额成员调用该友元函数，它也必须h是被声明过的.  
```
struct X{
    friend void f() {
    //函数体，友元函数可以定义在类的内部
    }  
    X(){f();}    //错误：f还没有被声明
    void g();
    void h();
    };
void X::g() {   return f();}   //错误，f还没有被声明;
void f();  //声明定义在类中的友元函数
void X::h() { return f();  }  //正确，现在f的声明在作用域中;
```
## 7.4.1  名字查找与类的作用域  
类额定义分两步处理:  
- 首先，编译成员的声明.  
- 直到类全部可见之后才编译函数体.   
类型名要特殊处理:  
- 在类中,如果成员使用了外层作用域中的名字，而该名字代表一种类型，则类不能在之后重新定义该名字.  
##### 成员定义中的普通块作用域的名字查找  
函数的形参可能会隐藏类的成员，所以，一般函数的形参不能用和类成员一样的名字.  
不要把成员名字当做作为参数其它局部变量使用.  
##### 构造函数的初始值有时不可少  
- 如果成员函数是const或者是引用的话，必须将其初始化.类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化.  
- 如果成员是const,引用=，或者属于某种未提供默认构造函数额类类型,我们必须通过构造函数初始值列表为这些成员提供初始值.  
- 成员初始化顺序和类定义中出现的顺序相同.  
- 如果一个构造函数为所有参数都提供了默认实参,则它实际上也定义了默认构造函数.  
## 7.5.2  委托构造函数  
一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些（或者全部）职责委托给了其他构造函数,  和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体，在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类本身，和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须和类中另外一个构造函数匹配.  







